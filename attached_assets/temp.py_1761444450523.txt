#!/usr/bin/env python3
"""
backend.py

Single-file Flask backend for local development that:
 - Lists available video formats/resolutions for a YouTube URL (/resolutions)
 - Downloads a selected format and returns it as an HTTP attachment (/download)

Dependencies:
  - Python packages: Flask, yt-dlp
      pip install Flask yt-dlp
  - System: ffmpeg (must be on PATH for merging/processing)

Notes:
  - Designed for local use / testing. Do NOT expose publicly without auth/rate-limiting.
  - Uses tempfile.mkdtemp() for per-request temp directories and schedules cleanup.
"""

import os
import shutil
import json
import uuid
import time
import threading
import tempfile
from pathlib import Path
from typing import Optional, Dict, Any, List

from flask import Flask, request, jsonify, send_file, abort, Response
from yt_dlp import YoutubeDL, utils as ytdlp_utils

app = Flask(__name__)

# How long to keep files after serving (seconds). Increase if you have slow clients.
CLEANUP_DELAY_SECONDS = 30

# Max allowed size for returned file in bytes (optional safety). Set to 0 to disable.
# e.g., 0 disables check; or set to 10 * 1024**3 for 10 GiB.
MAX_RETURN_FILE_SIZE = 0

# YT-DLP common options for metadata-only extraction
YTDLP_METADATA_OPTS = {
    "quiet": True,
    "no_warnings": True,
    "skip_download": True,
    "format": "best",
    # ensure JSON-like information
    "dump_single_json": True,
}


def schedule_cleanup(path: str, delay: int = CLEANUP_DELAY_SECONDS):
    """
    Remove 'path' (file or directory) after 'delay' seconds on a background thread.
    Keeps main thread free to return the response.
    """
    def _cleanup():
        try:
            time.sleep(delay)
            if os.path.isdir(path):
                shutil.rmtree(path, ignore_errors=True)
            elif os.path.exists(path):
                os.remove(path)
        except Exception as e:
            app.logger.warning(f"Cleanup failed for {path}: {e}")

    t = threading.Thread(target=_cleanup, daemon=True)
    t.start()


def safe_filename(s: str) -> str:
    """
    Create a filesystem-safe filename.
    Keep it simple: strip dangerous chars and limit length.
    """
    keep = "".join(c for c in s if c.isalnum() or c in " .-_()")
    return (keep[:200] or "output").strip()


def formats_to_frontend_list(formats: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
    """
    Convert raw yt-dlp 'formats' list into a simplified list for the frontend.
    Each item contains:
      - format_id (string)
      - ext (mp4, webm, m4a etc)
      - resolution (e.g., '1920x1080' or 'audio only')
      - height (int or None) so frontend can sort by height
      - note (additional info)
      - filesize (int bytes or None)
    """
    out = []
    for f in formats:
        # Some formats are audio-only (vcodec == "none") or video-only (acodec == "none")
        height = f.get("height")
        width = f.get("width")
        res = None
        if height and width:
            res = f"{width}x{height}"
        elif height:
            res = f"{height}p"
        elif f.get("vcodec") == "none":
            res = "audio only"
        else:
            res = f.get("format_note") or "unknown"

        out.append({
            "format_id": str(f.get("format_id")),
            "ext": f.get("ext"),
            "resolution": res,
            "height": height or 0,
            "note": f.get("format_note") or "",
            "filesize": f.get("filesize") or f.get("filesize_approx") or None,
            "vcodec": f.get("vcodec"),
            "acodec": f.get("acodec"),
        })
    # Sort descending by height (so highest resolution first)
    out.sort(key=lambda x: (x["height"] or 0), reverse=True)
    return out


@app.route("/health", methods=["GET"])
def health():
    return jsonify({"status": "ok", "message": "backend ready"}), 200


@app.route("/resolutions", methods=["POST"])
def resolutions():
    """
    Accepts JSON body: {"url": "https://www.youtube.com/watch?v=..."}
    Returns a simplified list of available formats.
    """
    data = request.get_json(silent=True)
    if not data or "url" not in data:
        return jsonify({"error": "JSON body required with 'url' field"}), 400

    url = data["url"].strip()
    if not url:
        return jsonify({"error": "Empty URL"}), 400

    # Basic URL validation (frontend should also validate)
    if ("youtube.com" not in url) and ("youtu.be" not in url):
        return jsonify({"error": "URL does not look like a YouTube link"}), 400

    try:
        ydl_opts = dict(YTDLP_METADATA_OPTS)
        # Use YoutubeDL to extract info without downloading
        with YoutubeDL(ydl_opts) as ydl:
            info = ydl.extract_info(url, download=False)
        # info will contain 'formats' (list)
        formats = info.get("formats", [])
        simplified = formats_to_frontend_list(formats)
        # Also include some video meta (title, duration)
        meta = {
            "id": info.get("id"),
            "title": info.get("title"),
            "uploader": info.get("uploader"),
            "duration": info.get("duration"),
            "thumbnail": info.get("thumbnail"),
        }
        return jsonify({"meta": meta, "formats": simplified}), 200
    except ytdlp_utils.DownloadError as e:
        app.logger.exception("yt-dlp failed to extract info")
        return jsonify({"error": "yt-dlp failed to fetch video info", "details": str(e)}), 500
    except Exception as e:
        app.logger.exception("Unexpected error in /resolutions")
        return jsonify({"error": "internal_error", "message": str(e)}), 500


def pick_format_id(formats_list: List[Dict[str, Any]], requested_resolution: Optional[str]) -> Optional[str]:
    """
    Choose a format_id based on requested_resolution string like "2160" or "4k" or full "2160p".
    If requested_resolution is None, pick the best combined (video+audio) format if possible.
    Strategy:
      1. If requested_resolution present, find the highest format with height >= requested (exact or nearest lower)
      2. Prefer formats that include both audio and video (acodec != 'none' and vcodec != 'none')
      3. If format entries are video-only, the frontend should pass a format_id that contains '+' (video+audio) or we let yt-dlp merge
    """
    if not formats_list:
        return None

    # normalize requested resolution into target height integer if possible
    target = None
    if requested_resolution:
        s = requested_resolution.lower().replace("p", "").replace("k", "000").strip()
        try:
            target = int(s)
        except Exception:
            target = None

    # If target set, try to find exact or nearest >= target that has both audio and video
    if target:
        # candidates with height >= target and both codecs
        candidates = [f for f in formats_list if (f.get("height") or 0) >= target and f.get("vcodec") != "none" and f.get("acodec") != "none"]
        if candidates:
            # pick smallest filesize among candidates or highest height? we'll prefer smallest height >= target
            candidates.sort(key=lambda x: (x.get("height") or 0, -(x.get("filesize") or 0)))
            return candidates[0]["format_id"]
        # fallback: find nearest lower
        lower = [f for f in formats_list if (f.get("height") or 0) < target and f.get("vcodec") != "none"]
        if lower:
            # choose highest available below target
            lower.sort(key=lambda x: (x.get("height") or 0), reverse=True)
            return lower[0]["format_id"]

    # If no target or nothing found, prefer bestvideo+bestaudio combined format id
    # Look for formats that are "full" (have both audio & video)
    full = [f for f in formats_list if f.get("vcodec") != "none" and f.get("acodec") != "none"]
    if full:
        # pick the highest height from full
        full.sort(key=lambda x: (x.get("height") or 0), reverse=True)
        return full[0]["format_id"]

    # If only video-only entries, return a value that causes yt-dlp to download bestvideo+bestaudio instead:
    return "bestvideo+bestaudio"


@app.route("/download", methods=["POST"])
def download():
    """
    Downloads and returns the requested video.

    Expected JSON body:
      {
        "url": "https://www.youtube.com/watch?v=ID",
        "format_id": "313+140"             # optional: exact yt-dlp format_id to download
        "resolution": "2160"               # optional: prefer 2160p/4k (used if format_id omitted)
        "no_audio": false                  # optional: strip audio if True
      }

    Behavior:
      - Creates a temp dir for the job
      - Uses yt-dlp (Python API) to download the selected format into the temp dir
      - If no_audio True, runs ffmpeg to strip audio
      - Streams the resulting file back as attachment
      - Schedules cleanup of temp dir after response is sent
    """
    data = request.get_json(silent=True)
    if not data or "url" not in data:
        return jsonify({"error": "JSON body required with 'url' field"}), 400

    url = data["url"].strip()
    format_id = data.get("format_id")
    resolution_pref = data.get("resolution")
    no_audio = bool(data.get("no_audio", False))

    if ("youtube.com" not in url) and ("youtu.be" not in url):
        return jsonify({"error": "URL does not look like a YouTube link"}), 400

    # Create unique workdir
    workdir = tempfile.mkdtemp(prefix="ytjob_")
    workdir_path = Path(workdir)
    app.logger.info(f"[DOWNLOAD] workdir = {workdir}")

    try:
        # 1) fetch metadata to list formats (so we can pick a format_id if not provided)
        with YoutubeDL(dict(YTDLP_METADATA_OPTS)) as ydl:
            info = ydl.extract_info(url, download=False)

        raw_formats = info.get("formats", [])
        simplified_formats = formats_to_frontend_list(raw_formats)

        # If the caller didn't provide a format_id, pick one based on resolution_pref
        chosen_format_id = format_id
        if not chosen_format_id:
            chosen_format_id = pick_format_id(simplified_formats, resolution_pref)

        if not chosen_format_id:
            return jsonify({"error": "Could not determine a format to download"}), 400

        # 2) Prepare yt-dlp download options
        # Use an output template inside the temp dir. Use title + random suffix for nice filename.
        safe_title = safe_filename(info.get("title", "video"))
        out_template = str(workdir_path / f"{safe_title}-%(id)s.%(ext)s")

        # merge_output_format ensures yt-dlp will use ffmpeg to merge into this container format
        # set 'format' to the chosen format_id (string)
        ytdlp_download_opts = {
            "format": chosen_format_id,
            "outtmpl": out_template,
            "merge_output_format": "mp4",  # final container when merging (mp4 is widely compatible)
            "quiet": True,
            "no_warnings": True,
            "noplaylist": True,
            # Avoid writing metadata to stderr interfering with Flask, but we log to app.logger as needed
        }

        app.logger.info(f"[DOWNLOAD] Starting yt-dlp download: format={chosen_format_id}")

        # Use YoutubeDL to perform the download into our tempdir
        with YoutubeDL(ytdlp_download_opts) as ydl:
            # Download returns list or single id. We call download([url])
            ydl.download([url])

        # After download, find the produced media file(s) in workdir
        files = list(workdir_path.iterdir())
        if not files:
            return jsonify({"error": "No files were produced by yt-dlp"}), 500

        # Choose the largest media file as candidate output
        media_files = [f for f in files if f.is_file() and f.stat().st_size > 0]
        if not media_files:
            return jsonify({"error": "No downloadable media files found after yt-dlp run"}), 500

        # Prefer mp4/mkv/webm with largest size
        media_files.sort(key=lambda p: p.stat().st_size, reverse=True)
        downloaded_file = media_files[0]

        # If user requested no_audio, run ffmpeg to strip audio track
        final_file_path = downloaded_file
        if no_audio:
            # create an output filename
            out_noaudio = workdir_path / f"{downloaded_file.stem}-noaudio.mp4"
            # ffmpeg: copy video stream, discard audio (-an)
            ffmpeg_cmd = [
                "ffmpeg", "-y",
                "-i", str(downloaded_file),
                "-c:v", "copy",
                "-an",
                str(out_noaudio)
            ]
            app.logger.info(f"[DOWNLOAD] Stripping audio with ffmpeg: {' '.join(ffmpeg_cmd)}")
            rc = os.system(" ".join(map(lambda x: f"'{x}'" if ' ' in x else x, ffmpeg_cmd)))
            if rc != 0:
                app.logger.warning("ffmpeg returned non-zero exit while stripping audio; falling back to original file")
            else:
                final_file_path = out_noaudio

        # Optional: safety check for file size
        if MAX_RETURN_FILE_SIZE and final_file_path.stat().st_size > MAX_RETURN_FILE_SIZE:
            # schedule cleanup and abort
            schedule_cleanup(workdir, delay=5)
            return jsonify({"error": "file_too_large", "size": final_file_path.stat().st_size}), 413

        # Prepare streaming response using Flask send_file (streams by default)
        # Determine a friendly filename for client download
        download_filename = f"{safe_title}-{info.get('id')}{final_file_path.suffix}"
        # Use send_file with conditional=False to let Flask handle streaming efficiently
        response = send_file(
            str(final_file_path),
            as_attachment=True,
            download_name=download_filename,
            conditional=True
        )

        # Schedule cleanup of workdir after a delay so file remains for client download
        schedule_cleanup(workdir, delay=CLEANUP_DELAY_SECONDS)

        return response
    except ytdlp_utils.DownloadError as e:
        app.logger.exception("yt-dlp download/extract error")
        # Ensure cleanup
        schedule_cleanup(workdir, delay=5)
        return jsonify({"error": "yt-dlp download failed", "details": str(e)}), 500
    except Exception as e:
        app.logger.exception("Unexpected error in /download")
        schedule_cleanup(workdir, delay=5)
        return jsonify({"error": "internal_error", "message": str(e)}), 500


if __name__ == "__main__":
    # Use Flask built-in server for local testing. For concurrency or production, use Gunicorn.
    app.run(host="127.0.0.1", port=5000, debug=True)
